Ошибочка произошла из-за неверного использования фильтра Jinja2. В стандартной библиотеке Jinja2 нет встроенного фильтра datetime. Чтобы форматировать дату корректно, можно либо передать уже сформатированную дату из Python, либо использовать собственный фильтр.

Решение №1: Форматирование даты на уровне Python

Можно привести дату к нужному формату ещё на этапе подготовки данных, передавая готовое значение в шаблон:

Python (обновлён):

cur.execute("""
    SELECT id, product_name, quantity, total_price, to_char(created_at, 'YYYY-MM-DD'), status
    FROM orders
    WHERE user_id=%s
    ORDER BY created_at DESC
""", (session["user_id"],))

orders = cur.fetchall()
return render_template('orders.html', orders=orders)

Обратите внимание на использование функции to_char() в SQL-запросе. Она вернёт дату в удобочитаемом формате, и в шаблоне останется просто вывести её:

<td>{{ order[4] }}</td>

Решение №2: Собственный фильтр Jinja2

Другой вариант — создать собственный фильтр Jinja2 для преобразования даты в нужный формат. Например, создадим такой фильтр в вашем приложении:

Новый код (создание собственного фильтра):

from jinja2 import Markup

@app.template_filter('datetime')
def format_datetime(value, fmt='%Y-%m-%d'):
    """Фильтр для форматирования дат."""
    return value.strftime(fmt)

# Применяется в шаблоне следующим образом:
<td>{{ order[4]|datetime }}</td>

Полностью исправленное приложение:

from flask import Flask, render_template, request, session, redirect, url_for, flash
import psycopg2
from datetime import datetime

app = Flask(__name__, static_folder="")
app.secret_key = '123123'
app.config['UPLOAD_FOLDER'] = './uploads/'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  

# Конфигурация для работы с сессией
app.config["SECRET_KEY"] = "super_secret_key"  # Замените на свою секретную фразу
app.config["SESSION_TYPE"] = "filesystem"      # Хранение сессий на файловой системе
from flask_session import Session
Session(app)

# Настройки подключения к базе данных
DATABASE_URL = 'postgresql://postgres:123123@localhost:5432/users_application'  # Ваш URL подключения к БД

# Функция для получения соединения с базой данных
def get_db_connection():
    conn = psycopg2.connect(DATABASE_URL)
    return conn

# Создание собственного фильтра для форматирования дат
@app.template_filter('datetime')
def format_datetime(value, fmt='%Y-%m-%d'):
    """Фильтр для форматирования дат."""
    return value.strftime(fmt)

# Роут для просмотра истории заказов
@app.route('/history', methods=['GET'])
def history():
    # Проверяем, залогинен ли пользователь
    if not session.get("logged_in"):
        flash('Вам необходимо войти в систему!', 'warning')
        return redirect(url_for('login'))
    
    # Подключаемся к базе данных
    conn = get_db_connection()
    cur = conn.cursor()
    
    # Выполняем запрос с сортировкой по дате заказа
    cur.execute("""
        SELECT id, product_name, quantity, total_price, created_at, status
        FROM orders
        WHERE user_id=%s
        ORDER BY created_at DESC
    """, (session["user_id"],))
    
    # Берём все полученные заказы
    orders = cur.fetchall()
    
    # Закрываем подключение
    cur.close()
    conn.close()
    
    # Передаём данные в шаблон
    return render_template('orders.html', orders=orders)

if __name__ == '__main__':
    app.run(debug=True)

Шаблон HTML (исправлено):

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>История заказов</title>
    <link rel="stylesheet" href="css/orders.css">
</head>
<body>
    <h1>История ваших заказов</h1>
    <table id="orders-table">
        <thead>
            <tr>
                <th>Номер заказа</th>
                <th>Продукт</th>
                <th>Количество</th>
                <th>Стоимость</th>
                <th>Дата заказа</th>
                <th>Статус</th>
            </tr>
        </thead>
        <tbody>
            {% for order in orders %}
                <tr>
                    <td>{{ order[0] }}</td>
                    <td>{{ order[1] }}</td>
                    <td>{{ order[2] }}</td>
                    <td>{{ "%.2f"|format(order[3]) }} руб.</td>
                    <td>{{ order[4]|datetime }}</td>
                    <!-- Интерпретация статусов -->
                    <td>{% if order[5] == 1 %}Новый{% elif order[5] == 2 %}В обработке{% elif order[5] == 3 %}Выполненный{% else %}{{order[5]}}{% endif %}</td>
                </tr>
            {% endfor %}
        </tbody>
    </table>
    <a href="/">Вернуться на главную страницу</a>
</body>
</html>

Теперь всё должно работать без ошибок, и даты будут отображаться корректно в формате %Y-%m-%d.